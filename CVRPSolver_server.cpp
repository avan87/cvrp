// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "CVRPSolver.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include "main.h"
#include "matr.h"


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;











class CVRPSolverHandler : virtual public CVRPSolverIf {
 public:
  CVRPSolverHandler() {
    // Your initialization goes here
  }

  void routes(std::vector<std::vector<int64_t> > & _return, const std::vector<std::vector<int64_t> > & vec, const std::vector<int64_t> & demands, const std::vector<int64_t> & v_caps) {
    // Your implementation goes here



      int size = vec.size();
      int demandSize  = demands.size();

     std::vector<long long int> v2 (size, 0);
      std::vector<long long int> dem (demandSize, 0);
      std::vector<long long int> veh_caps(v_caps.size(),0);

      std::vector<std::vector<long long int>> tempVec(size, v2);

      for(int i=0; i< tempVec.size(); i++) {
            for (int j=0;j<tempVec[i].size(); j++){

              tempVec[i][j] = (long long int) vec[i][j];
             // std::cout << tempVec[i][j] << " ";
         }
           // std::cout << std::endl;
      }


      for(int i=0; i< demandSize; i++) {

          dem[i] = demands[i];
      }


      for(int i=0; i< v_caps.size(); i++) {

          veh_caps[i] = v_caps[i];
      }







      operations_research::Matrix matrix(tempVec, dem, veh_caps);
      operations_research::VRPSolver vrpSolver;

      std::vector<std::vector<int64>> cvrp_result = vrpSolver.SolveVRP(matrix, veh_caps.size());




      for(int i=0; i< cvrp_result.size(); i++) {

          _return.push_back(std::vector<int64_t>(0,0));
            for (int j = 0; j < cvrp_result[i].size(); j++){

              _return[i].push_back((int64_t) cvrp_result[i][j]);
         }
      }





    printf("routes\n");
  }

};

int main(int argc, char **argv) {
  int port = 9090;
  shared_ptr<CVRPSolverHandler> handler(new CVRPSolverHandler());
  shared_ptr<TProcessor> processor(new CVRPSolverProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
    std::cout << "listening..." <<std::endl;
  server.serve();
  return 0;
}

